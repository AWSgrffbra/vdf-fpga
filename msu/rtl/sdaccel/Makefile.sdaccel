.PHONY: help

help::
	$(ECHO) "Makefile Usage:"
	$(ECHO) "  make all TARGET=<sw_emu/hw_emu/hw> DEVICE=<FPGA platform>"
	$(ECHO) "      Generate the design for specified Target and Device."
	$(ECHO) ""
	$(ECHO) "  make clean "
	$(ECHO) "      Remove the generated non-hardware files."
	$(ECHO) ""
	$(ECHO) "  make cleanall"
	$(ECHO) "      Remove all the generated files."
	$(ECHO) ""
	$(ECHO) "  make check TARGET=<sw_emu/hw_emu/hw> DEVICE=<FPGA platform>"
	$(ECHO) "      Run application in emulation."
	$(ECHO) ""


# Model configuration
WORD_LEN               = 16
NONREDUNDANT_ELEMENTS ?= 8
NUM_URAMS             ?= 0

MODULUS               := $(shell python3 -c \
	  "import random; \
           bits = $(NONREDUNDANT_ELEMENTS)*$(WORD_LEN); \
	   M = random.getrandbits(bits); \
           print(M)")

HOST_FLAGS_HW_EMU  = -e -f 4 -u $(NUM_URAMS)
HOST_FLAGS_FPGA    = -e -f 4 -u $(NUM_URAMS)

# 128b
#NONREDUNDANT_ELEMENTS  = 8
#MODULUS                = 302934307671667531413257853548643485645

# 256b
#NONREDUNDANT_ELEMENTS  = 16
#MODULUS                = 22399791080850639135831474318415907634282253441172412823115487127449803544730

# 512b
#NONREDUNDANT_ELEMENTS  = 32
#MODULUS                = 6489662188004289912380470564448077957325054535910000462604166663459673710886837850185567098610688907939251192940184027313309919696320700640064979438888128

# 1024b
NONREDUNDANT_ELEMENTS  = 64
MODULUS                = 435498004454960311370317052397000844802649144205780523913417362625407607066231475209709961473477443808083986632633065072597378881054561793869773671502511117663614834848276234008576433331085414399994150596781014081314102597766163665183768312980812151246986379323231704775209109465985927509514160947756090729

# 2048b
#NONREDUNDANT_ELEMENTS  = 128
#MODULUS                = 27271074554676503519391853169046884655581831532712325396502630600760020898632119957064692546985308544150784261990781284771270896020978275111752108656098548870476692410787307573844664727606744662496584291979219988855628209868679955413354284586208135049013661377422927304865632743549276675135791608153703621521387919523133145389506743398898429233228241599150945874146271663618317884751301381861848237319575680595184886001249116411859073517763435609872023182784481435349116944758451761798946340486903179689195662213716695366603101279184654887537500992719023646034937427991533743798093191230930642530828318735313860873305

# Synthesis directives
#SRC_DIR=/data/examples/getting_started/rtl_kernel/rtl_vdf_newred
LDCLFLAGS += --xp "vivado_prop:run.pfm_dynamic_vdf_1_0_synth_1.\
                   {STEPS.SYNTH_DESIGN.ARGS.FANOUT_LIMIT}={400}"
LDCLFLAGS += --xp "vivado_prop:run.impl_1.\
                   {STEPS.OPT_DESIGN.ARGS.DIRECTIVE}={Explore}"
#LDCLFLAGS += --xp "vivado_prop:run.impl_1.\
                   {STEPS.PLACE_DESIGN.ARGS.DIRECTIVE}={SSI_HighUtilSLRs}"
#LDCLFLAGS += --xp "vivado_prop:run.impl_1.\
#                   {STEPS.PLACE_DESIGN.ARGS.DIRECTIVE}={SSI_SpreadLogic_High}"
LDCLFLAGS += --xp "vivado_prop:run.impl_1.\
                   {STEPS.PLACE_DESIGN.ARGS.DIRECTIVE}={Explore}"
#LDCLFLAGS += --xp "vivado_prop:run.impl_1.\
#                   {STEPS.PLACE_DESIGN.ARGS.DIRECTIVE}={ExtraTimingOpt}"
LDCLFLAGS += --xp "vivado_prop:run.impl_1.\
                   {STEPS.PHYS_OPT_DESIGN.ARGS.DIRECTIVE}=\
                   {AlternateFlowWithRetiming}"

# Vivado 2018.3
LDCLFLAGS += --xp "vivado_prop:run.impl_1.\
                   {STEPS.ROUTE_DESIGN.ARGS.DIRECTIVE}={AggressiveExplore}"
LDCLFLAGS += --xp "vivado_prop:run.impl_1.\
                   {STEPS.POST_ROUTE_PHYS_OPT_DESIGN.ARGS.DIRECTIVE}=\
                   {AggressiveExplore}"

# Add in additional constraints, such as pblocks
# This places all performance critical logic in SLR2 which is
# free of shell logic. 
PLACER_CONSTRS     = $(realpath ../placer_constrs.xdc)
LDCLFLAGS += --xp "vivado_prop:run.impl_1.{STEPS.PLACE_DESIGN.TCL.PRE}=\
                   $(PLACER_CONSTRS)"

LDCLFLAGS += --kernel_frequency 158

LDCLFLAGS += --report system


# Points to Utility Directory
COMMON_REPO        = $(AWS_FPGA_REPO_DIR)/SDAccel/examples/xilinx
ABS_COMMON_REPO    = $(shell readlink -f $(COMMON_REPO))

ROOT_DIR           = $(realpath ../../../..)
MODSQR_DIR         = $(ROOT_DIR)/modular_square
SCRIPTS_DIR        = ../tcl
HOST_SRC_DIR       = $(ROOT_DIR)/msu/sw

HOST_SRCS         += $(HOST_SRC_DIR)/MSUSDAccel.cpp
HOST_SRCS         += $(HOST_SRC_DIR)/MSU.cpp
HOST_SRCS         += $(HOST_SRC_DIR)/main.cpp

CXXFLAGS          += -I$(HOST_SRC_DIR) -DFPGA=1 \
	             -DMODULUS=\"$(MODULUS)\" \
                     -DNONREDUNDANT_ELEMENTS=$(NONREDUNDANT_ELEMENTS)

TARGETS           := hw
TARGET            := $(TARGETS)
DEVICE            := $(AWS_PLATFORM)
XCLBIN            := ./xclbin

include ../utils.mk

DSA               := $(call device2sandsa, $(DEVICE))
BUILD_DIR         := ./vdf_9cc/_x.$(TARGET).$(DSA)

CXX               := $(XILINX_SDX)/bin/xcpp
XOCC              := $(XILINX_SDX)/bin/xocc
VIVADO            := vivado

# Include Libraries
include $(ABS_COMMON_REPO)/libs/opencl/opencl.mk
include $(ABS_COMMON_REPO)/libs/xcl2/xcl2.mk
CXXFLAGS          += $(xcl2_CXXFLAGS)
LDFLAGS           += $(xcl2_LDFLAGS)
HOST_SRCS         += $(xcl2_SRCS)

CXXFLAGS          += $(opencl_CXXFLAGS) -Wall -O0 -std=c++14
LDFLAGS           += $(opencl_LDFLAGS) -lgmp

# Host compiler global settings
CXXFLAGS          += -fmessage-length=0
LDFLAGS           += -lrt -lstdc++ 

# Kernel compiler global settings
CLFLAGS           += -t $(TARGET) --platform $(DEVICE) 
CLFLAGS           += --save-temps --temp_dir $(BUILD_DIR) 

# Enable tracing
# TODO - for some reason the model fails when tracing is off
TRACE              = 1
CLFLAGS           += -g

EXECUTABLE         = host

EMCONFIG_DIR       = $(XCLBIN)/$(DSA)

BINARY_CONTAINERS += $(XCLBIN)/vdf.$(TARGET).$(DSA).xclbin
BINARY_CONTAINER_vdf_OBJS += $(XCLBIN)/vdf.$(TARGET).$(DSA).xo

CP = cp -rf

.PHONY: all clean cleanall docs emconfig
all: check-devices $(EXECUTABLE) $(BINARY_CONTAINERS) emconfig

.PHONY: exe
exe: $(EXECUTABLE)

# Gather source files needed to run sdx
sdx:
	mkdir -p                          sdx/src
	cp $(HOST_SRCS)                   sdx/src
	cp $(xcl2_HDRS)                   sdx/src
	cp $(XCLBIN)/vdf.hw_emu.$(DSA).xo sdx/src
	cp $(HOST_SRC_DIR)/*.cpp          sdx/src
	cp $(HOST_SRC_DIR)/*.hpp          sdx/src
	cp mem/*.dat                      sdx/src

# Configure MSU parameters. These are included through vdf_kernel.sv
msuconfig.vh:
	echo "\`define NONREDUNDANT_ELEMENTS_DEF $(NONREDUNDANT_ELEMENTS)" \
              > msuconfig.vh

# Generate the LUTs. reduction_lut_000.dat will be present for any bitwidth.
$(BINARY_CONTAINER_vdf_OBJS): mem/reduction_lut_000.dat
$(BINARY_CONTAINER_vdf_OBJS): msuconfig.vh
mem/reduction_lut_000.dat: 
	mkdir -p mem
	cd mem && $(MODSQR_DIR)/rtl/gen_reduction_lut.py \
                          --nonredundant $(NONREDUNDANT_ELEMENTS) \
                          --modulus $(MODULUS) \
                          --urams $(NUM_URAMS)

sdaccel.ini:
ifeq ($(TRACE), 1)
	echo "[Emulation]" > sdaccel.ini
	echo "launch_waveform=batch" >> sdaccel.ini
	echo "[Debug]" >> sdaccel.ini
	echo "profile=true" >> sdaccel.ini
	echo "timeline_trace=true" >> sdaccel.ini
	echo "device_profile=true" >> sdaccel.ini

$(BINARY_CONTAINER_vdf_OBJS): sdaccel.ini
else
	rm -f sdaccel.ini
endif

xo: $(XCLBIN)/vdf.$(TARGET).$(DSA).xo

$(XCLBIN)/vdf.$(TARGET).$(DSA).xo:
	mkdir -p ${XCLBIN}
	$(VIVADO) -mode batch -source $(SCRIPTS_DIR)/gen_xo.tcl \
                  -tclargs $@ vdf hw $(DEVICE)


# Building kernel
$(XCLBIN)/vdf.$(TARGET).$(DSA).xclbin: $(BINARY_CONTAINER_vdf_OBJS)
	mkdir -p $(XCLBIN)
	$(XOCC) $(CLFLAGS) $(LDCLFLAGS) \
             -lo $(XCLBIN)/vdf.$(TARGET).$(DSA).xclbin \
             $(XCLBIN)/vdf.$(TARGET).$(DSA).xo

# Building Host
$(EXECUTABLE): $(HOST_SRCS) $(HOST_HDRS)
	mkdir -p $(XCLBIN)
	$(CXX) $(CXXFLAGS) $(HOST_SRCS) $(HOST_HDRS) -o '$@' $(LDFLAGS)

emconfig:$(EMCONFIG_DIR)/emconfig.json
$(EMCONFIG_DIR)/emconfig.json:
	emconfigutil --platform $(DEVICE) --od $(EMCONFIG_DIR)

check: all
ifeq ($(TARGET),$(filter $(TARGET),sw_emu hw_emu))
	$(CP) $(EMCONFIG_DIR)/emconfig.json .
	XCL_EMULATION_MODE=$(TARGET) ./$(EXECUTABLE) $(HOST_FLAGS_HW_EMU)
else
	 ./$(EXECUTABLE) $(HOST_FLAGS_FPGA)
endif

ifneq ($(TARGET),$(findstring $(TARGET), hw hw_emu))
$(warning WARNING:Application supports only hw hw_emu TARGET. \
  Please use the target for running the application)
endif


# Cleaning stuff
clean:
	-$(RMDIR) $(EXECUTABLE) $(XCLBIN)/{*sw_emu*,*hw_emu*} 
	-$(RMDIR) sdaccel_* TempConfig system_estimate.xtxt *.rpt
	-$(RMDIR) src/*.ll _xocc_* .Xil emconfig.json 
	-$(RMDIR) dltmp* xmltmp* *.log *.jou *.wcfg *.wdb
	-$(RMDIR) mem

cleanall: clean
	-$(RMDIR) $(XCLBIN)
	-$(RMDIR) _x.*
	-$(RMDIR) ./tmp_kernel_pack* ./packaged_kernel* 
	-$(RMDIR) mem
